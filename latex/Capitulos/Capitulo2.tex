\chapter{Glycan RegEx}

Neste capítulo, descrevemos o funcionamento do sistema \texttt{Glycan RegEx}
implementado no módulo \texttt{glycowork.motif.regex}, suas funções principais,
o papel das expressões regulares e as vantagens do uso desse sistema.

O \texttt{Glycan RegEx}, introduzido por Bennett e Bojar (2024) no pacote
\texttt{glycowork}, representa um avanço significativo na análise computacional
de glicanos ao acrescentar o uso de RegEx para identificação e extração de
motifs. Tal sistema foi proposto como uma adaptação das tradicionais RegEx de
ciência da computação, permitindo a detecção de motifs na estrutura não linear
dos glicanos, possibilitando buscas precisas e otimizadas nestes elementos.

\section{Conceito e funcionamento}

O \texttt{Glycan RegEx} se baseia na tradução de padrões RegEx para operações
de isomorfismo de subgrafos dentro das estruturas moleculares de glicanos.
Quando o usuário fornece um padrão o sistema decompõe este padrão em unidades
menores, chamadas de módulos homogêneos, correspondentes a monossacarídeos e
ligações individuais. Cada módulo é então processado para identificar as
possíveis correspondências no grafo do glicano, permitindo localizar
subestruturas equivalentes de forma independente da forma textual em que o
glicano foi representado. Isso é essencial, já que o módulo aceita diversos
formatos de entrada, como GlycoCT, Oxford e demais notações.

Estas RegEx têm uma sintaxe muito similar às clássicas RegEx textuais mas com
uma semântica diferente: como os glicanos não são simples cadeias de caracteres
mas sim estruturas que podem ser representadas por grafos, o \texttt{Glycan
	RegEx} deve buscar não por símbolos (a, b, c) mas por monossacarídeos (GlcNac,
Man) e suas ligações; como exemplo, buscar pelo motif $A\alpha1-3B$, onde $A$ e
$B$ são monossacarídeos quaisquer, requer buscar em qualquer ponto do grafo do
glicano onde essa ligação $\alpha1-3$ ocorre.

Desse modo, este modelo de RegEx permite suporte a modificadores,
quantificadores, operadores de busca contextual e curingas mas com novos
significados, como:
\begin{itemize}
	\item $()$: representa uma ramificação/subárvore dentro do subgrafo. Exemplo: $Man(HexNAc)$, indicando um motif com uma unidade $Man$ com uma ramificação $HexNAc$;
	\item $[]*$: representa um motif que pode ocorrer zero ou mais vezes. Exemplo: $[HexNAc]*$;
	\item $[]+$: ao menos uma repetição de uma unidade. Exemplo: $[HexNaC]$;
	\item ${}$: especifica a quantidade de ocorrências. Exemplo: $[HexNAc]{2,}$, indicando um motif com ao menos duas ocorrências deste monossacarídeo.
\end{itemize}

% TODO: add mais?

O funcionamento interno do \texttt{Glycan RegEx} ocorre, a princípio, com a
segmentação da RegEx em módulos homogêneos: cada módulo é classificado como
simples quando não há a presença de modificadores ou quantificadores ou
complexo quando há; módulos simples são armazenados no formato de
\texttt{string}, enquanto os complexos são salvos em dicionários. Em seguida,
cada módulo é convertido em um grafo e por meio de operações de isomorfismo de
subgrafos é detectado onde cada subgrafo se encaixa no glicano completo.
Durante tal processo de detecção ocorre também a aplicação dos modificadores e
quantificadores dos módulos complexos, o que permite descartar de forma
otimizada subgrafos que não atinjam aos requisitos definidos, como número
específico de ocorrências do padrão.

Ao fim, com o processamento de todos os módulos, ocorre a construção do caminho
através do glicano que une todas as correspondências parciais e validadas pelos
requisitos definidos na expressão completa reconstruindo, dessa forma, o motif
exato a ser buscado. Essa abordagem possibilita representar ligações
específicas, como $\alpha$1-3 ou $\beta$1-6, bem como ambiguidade estrutural e
ramificações expressas por meio de parênteses. Dessa forma, a notação
\texttt{RegEx} é adaptada à topologia molecular, permitindo uma modelagem
altamente expressiva e precisa das estruturas glicosídicasuscado.

Todo este processo é executado por diversas funções internas da biblioteca,
dentre as quais se destacam:
\begin{itemize}
	\item \texttt{preprocess\_pattern()}: Particiona a RegEx fornecida em uma lista de padrões menores (módulos);
	\item \texttt{process\_complex\_pattern()}: Verifica por meio de isomorfismo de subgrafos se um padrão complexo (com modificadores/quantificadores) está presente no glicano;
	\item \texttt{process\_simple\_pattern()}: Verifica por meio de isomorfismo de subgrafos se um padrão simples (sem modificadores/quantificadores) está presente no glicano;
	\item \texttt{match\_it\_up()}: Para cada módulo, formata este em uma cadeia de caracteres ou dicionário, executa a função \texttt{process\_complex\_pattern()} ou \texttt{process\_simple\_pattern()} e retorna os módulos que representam os subgrafos que foram encontrados;
	\item \texttt{trace\_path()}: Conecta cada subgrafo encontrado na estrutura do glicano e retorna o caminho completo;
	\item \texttt{get\_match()}: Extrai trechos da estrutura do glicano que correspondem ao motif buscado pelo usuário, concentrando todo o processo por chamadas às demais funções.
\end{itemize}

\section{Vantagens da RegEx no contexto do \texttt{glycowork}}

Como comentado, a inovação trazida pelo \texttt{Glycan RegEx} ao framework
\texttt{glycowork} consiste na união do método tradicional de busca por motifs
com isomorfismo de subgrafo e o uso de um sistema de expressões regulares
específico para glicanos.

Sem o uso das expressões regulares, há a necessidade de uma base estática de
motifs já conhecidos. Essa base pode ser observada no arquivo
\texttt{common\_names.json} do próprio framework. Além disso, torna-se
necessário o uso de múltiplas combinações de padrões para detectar motifs
complexos e específicos do glicano, bem como lidar com a dificuldade de
capturar contextos mais amplos, como a ocorrência de um motif presente apenas
em um ramo do glicano. Todos esses fatores culminam em um uso bastante rígido
e, por vezes, difícil de representar de forma computacional.

Com a introdução do sistema \texttt{Glycan RegEx} é possível escrever padrões
de buscas de motifs em um formato mais declarativo e eficaz, com uso de
operadores clássicos que permitem negação, repetição e demais operações. Dessa
forma, o algoritmo de busca de motifs tem a capacidade de gerar diversos
subgrafos intermediários, ao contrário do mecanismo anterior que gera somente
um por motif, encontrando a combinação ideal de motifs de forma refinada e mais
simples para o programador.

Esta camada adicional que o sistema traz pode gerar um \textit{overhead} em
estruturas mais simples do glicano quando comparado com a busca tradicional do
\texttt{glycowork} por motifs estáticos. Entretanto, quando aplicado em
glicanos mais complexos ou maiores, tal mecanismo se sobressai tanto em
eficiência computacional quanto em simplicidade, pois será necessária somente
uma expressão para encontrar o motif desejado.

